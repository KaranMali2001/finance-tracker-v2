// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: job.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNewJob = `-- name: CreateNewJob :one
INSERT INTO jobs (
user_id,job_type,job_id,payload,attempts,queue_name,metadata,status
)VALUES (
$1,$2,$3,$4,$5,$6,$7,$8)
RETURNING id, user_id, job_type, job_id, status, payload, result, attempts, max_attempts, last_error, priority, queue_name, started_at, locked_at, finished_at, locked_by, timeout_seconds, metadata, created_at, updated_at
`

type CreateNewJobParams struct {
	UserID    pgtype.Text
	JobType   NullJobType
	JobID     pgtype.Text
	Payload   []byte
	Attempts  pgtype.Int4
	QueueName pgtype.Text
	Metadata  []byte
	Status    NullJobStatus
}

func (q *Queries) CreateNewJob(ctx context.Context, arg CreateNewJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createNewJob,
		arg.UserID,
		arg.JobType,
		arg.JobID,
		arg.Payload,
		arg.Attempts,
		arg.QueueName,
		arg.Metadata,
		arg.Status,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobType,
		&i.JobID,
		&i.Status,
		&i.Payload,
		&i.Result,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.Priority,
		&i.QueueName,
		&i.StartedAt,
		&i.LockedAt,
		&i.FinishedAt,
		&i.LockedBy,
		&i.TimeoutSeconds,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobById = `-- name: GetJobById :one
SELECT id, user_id, job_type, job_id, status, payload, result, attempts, max_attempts, last_error, priority, queue_name, started_at, locked_at, finished_at, locked_by, timeout_seconds, metadata, created_at, updated_at from jobs WHERE job_id=$1
`

func (q *Queries) GetJobById(ctx context.Context, jobID pgtype.Text) (Job, error) {
	row := q.db.QueryRow(ctx, getJobById, jobID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobType,
		&i.JobID,
		&i.Status,
		&i.Payload,
		&i.Result,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.Priority,
		&i.QueueName,
		&i.StartedAt,
		&i.LockedAt,
		&i.FinishedAt,
		&i.LockedBy,
		&i.TimeoutSeconds,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateJob = `-- name: UpdateJob :one
UPDATE jobs j
SET
  status = COALESCE($2, j.status),
  attempts = COALESCE($3, j.attempts),
  result = COALESCE($4, j.result),
last_error = COALESCE($5, j.last_error),
finished_at=COALESCE($6,j.finished_at)

WHERE j.id=$1
RETURNING id, user_id, job_type, job_id, status, payload, result, attempts, max_attempts, last_error, priority, queue_name, started_at, locked_at, finished_at, locked_by, timeout_seconds, metadata, created_at, updated_at
`

type UpdateJobParams struct {
	ID         pgtype.UUID
	Status     NullJobStatus
	Attempts   pgtype.Int4
	Result     []byte
	LastError  pgtype.Text
	FinishedAt pgtype.Timestamp
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, updateJob,
		arg.ID,
		arg.Status,
		arg.Attempts,
		arg.Result,
		arg.LastError,
		arg.FinishedAt,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobType,
		&i.JobID,
		&i.Status,
		&i.Payload,
		&i.Result,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.Priority,
		&i.QueueName,
		&i.StartedAt,
		&i.LockedAt,
		&i.FinishedAt,
		&i.LockedBy,
		&i.TimeoutSeconds,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

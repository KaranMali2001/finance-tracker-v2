// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: account.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (account_number,account_type,account_name,bank_id,user_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, bank_id, account_number, account_type, account_name, current_balance, is_primary, is_active, created_at, updated_at, deleted_at
`

type CreateAccountParams struct {
	AccountNumber string
	AccountType   string
	AccountName   pgtype.Text
	BankID        pgtype.UUID
	UserID        string
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.AccountNumber,
		arg.AccountType,
		arg.AccountName,
		arg.BankID,
		arg.UserID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BankID,
		&i.AccountNumber,
		&i.AccountType,
		&i.AccountName,
		&i.CurrentBalance,
		&i.IsPrimary,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAccountById = `-- name: GetAccountById :one
SELECT accounts.id, user_id, bank_id, account_number, account_type, account_name, current_balance, is_primary, accounts.is_active, accounts.created_at, accounts.updated_at, deleted_at, banks.id, name, code, banks.is_active, banks.created_at, banks.updated_at FROM accounts LEFT JOIN banks ON accounts.bank_id=banks.id WHERE accounts.id=$1 AND accounts.user_id=$2 AND accounts.deleted_at IS NULL
`

type GetAccountByIdParams struct {
	ID     pgtype.UUID
	UserID string
}

type GetAccountByIdRow struct {
	ID             pgtype.UUID
	UserID         string
	BankID         pgtype.UUID
	AccountNumber  string
	AccountType    string
	AccountName    pgtype.Text
	CurrentBalance pgtype.Numeric
	IsPrimary      pgtype.Bool
	IsActive       pgtype.Bool
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	DeletedAt      pgtype.Timestamp
	ID_2           pgtype.UUID
	Name           pgtype.Text
	Code           pgtype.Text
	IsActive_2     pgtype.Bool
	CreatedAt_2    pgtype.Timestamp
	UpdatedAt_2    pgtype.Timestamp
}

func (q *Queries) GetAccountById(ctx context.Context, arg GetAccountByIdParams) (GetAccountByIdRow, error) {
	row := q.db.QueryRow(ctx, getAccountById, arg.ID, arg.UserID)
	var i GetAccountByIdRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BankID,
		&i.AccountNumber,
		&i.AccountType,
		&i.AccountName,
		&i.CurrentBalance,
		&i.IsPrimary,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ID_2,
		&i.Name,
		&i.Code,
		&i.IsActive_2,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getAccountsByUserId = `-- name: GetAccountsByUserId :many
SELECT accounts.id, user_id, bank_id, account_number, account_type, account_name, current_balance, is_primary, accounts.is_active, accounts.created_at, accounts.updated_at, deleted_at, banks.id, name, code, banks.is_active, banks.created_at, banks.updated_at FROM accounts LEFT JOIN banks ON accounts.bank_id=banks.id WHERE accounts.user_id=$1 AND accounts.deleted_at IS NULL
`

type GetAccountsByUserIdRow struct {
	ID             pgtype.UUID
	UserID         string
	BankID         pgtype.UUID
	AccountNumber  string
	AccountType    string
	AccountName    pgtype.Text
	CurrentBalance pgtype.Numeric
	IsPrimary      pgtype.Bool
	IsActive       pgtype.Bool
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	DeletedAt      pgtype.Timestamp
	ID_2           pgtype.UUID
	Name           pgtype.Text
	Code           pgtype.Text
	IsActive_2     pgtype.Bool
	CreatedAt_2    pgtype.Timestamp
	UpdatedAt_2    pgtype.Timestamp
}

func (q *Queries) GetAccountsByUserId(ctx context.Context, userID string) ([]GetAccountsByUserIdRow, error) {
	rows, err := q.db.Query(ctx, getAccountsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsByUserIdRow
	for rows.Next() {
		var i GetAccountsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BankID,
			&i.AccountNumber,
			&i.AccountType,
			&i.AccountName,
			&i.CurrentBalance,
			&i.IsPrimary,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.Name,
			&i.Code,
			&i.IsActive_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE accounts a SET
  account_number=COALESCE($1, a.account_number),
  account_type=COALESCE($2, a.account_type),
  account_name=COALESCE($3, a.account_name),
  current_balance=COALESCE($4, a.current_balance),
  is_primary=COALESCE($5, a.is_primary),
  bank_id=COALESCE($6, a.bank_id),
  deleted_at=COALESCE($7, a.deleted_at)
FROM banks b
WHERE a.id=$8 AND a.user_id=$9 AND a.deleted_at IS NULL AND a.bank_id = b.id
RETURNING a.id, a.user_id, a.bank_id, a.account_number, a.account_type, a.account_name, a.current_balance, a.is_primary, a.is_active, a.created_at, a.updated_at, a.deleted_at, b.id AS bank_id, b.name AS bank_name, b.code AS bank_code, 
          b.is_active AS bank_is_active, b.created_at AS bank_created_at, 
          b.updated_at AS bank_updated_at
`

type UpdateAccountParams struct {
	AccountNumber  string
	AccountType    string
	AccountName    pgtype.Text
	CurrentBalance pgtype.Numeric
	IsPrimary      pgtype.Bool
	BankID         pgtype.UUID
	DeletedAt      pgtype.Timestamp
	ID             pgtype.UUID
	UserID         string
}

type UpdateAccountRow struct {
	ID             pgtype.UUID
	UserID         string
	BankID         pgtype.UUID
	AccountNumber  string
	AccountType    string
	AccountName    pgtype.Text
	CurrentBalance pgtype.Numeric
	IsPrimary      pgtype.Bool
	IsActive       pgtype.Bool
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	DeletedAt      pgtype.Timestamp
	BankID_2       pgtype.UUID
	BankName       string
	BankCode       pgtype.Text
	BankIsActive   pgtype.Bool
	BankCreatedAt  pgtype.Timestamp
	BankUpdatedAt  pgtype.Timestamp
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (UpdateAccountRow, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.AccountNumber,
		arg.AccountType,
		arg.AccountName,
		arg.CurrentBalance,
		arg.IsPrimary,
		arg.BankID,
		arg.DeletedAt,
		arg.ID,
		arg.UserID,
	)
	var i UpdateAccountRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BankID,
		&i.AccountNumber,
		&i.AccountType,
		&i.AccountName,
		&i.CurrentBalance,
		&i.IsPrimary,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.BankID_2,
		&i.BankName,
		&i.BankCode,
		&i.BankIsActive,
		&i.BankCreatedAt,
		&i.BankUpdatedAt,
	)
	return i, err
}

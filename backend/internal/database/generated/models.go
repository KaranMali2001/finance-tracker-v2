// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package generated

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type JobStatus string

const (
	JobStatusPending    JobStatus = "pending"
	JobStatusProcessing JobStatus = "processing"
	JobStatusFailed     JobStatus = "failed"
	JobStatusCompleted  JobStatus = "completed"
)

func (e *JobStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobStatus(s)
	case string:
		*e = JobStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for JobStatus: %T", src)
	}
	return nil
}

type NullJobStatus struct {
	JobStatus JobStatus
	Valid     bool // Valid is true if JobStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobStatus) Scan(value interface{}) error {
	if value == nil {
		ns.JobStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobStatus), nil
}

type JobType string

const (
	JobTypeWELCOMEEMAIL       JobType = "WELCOME_EMAIL"
	JobTypeWEBHOOK            JobType = "WEBHOOK"
	JobTypeBANKRECONCILIATION JobType = "BANK_RECONCILIATION"
	JobTypeREPORTS            JobType = "REPORTS"
)

func (e *JobType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobType(s)
	case string:
		*e = JobType(s)
	default:
		return fmt.Errorf("unsupported scan type for JobType: %T", src)
	}
	return nil
}

type NullJobType struct {
	JobType JobType
	Valid   bool // Valid is true if JobType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobType) Scan(value interface{}) error {
	if value == nil {
		ns.JobType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobType), nil
}

type ReconciliationActor string

const (
	ReconciliationActorSYSTEM ReconciliationActor = "SYSTEM"
	ReconciliationActorUSER   ReconciliationActor = "USER"
)

func (e *ReconciliationActor) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ReconciliationActor(s)
	case string:
		*e = ReconciliationActor(s)
	default:
		return fmt.Errorf("unsupported scan type for ReconciliationActor: %T", src)
	}
	return nil
}

type NullReconciliationActor struct {
	ReconciliationActor ReconciliationActor
	Valid               bool // Valid is true if ReconciliationActor is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullReconciliationActor) Scan(value interface{}) error {
	if value == nil {
		ns.ReconciliationActor, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ReconciliationActor.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullReconciliationActor) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ReconciliationActor), nil
}

type ReconciliationResultType string

const (
	ReconciliationResultTypeHIGHCONFIDENCEMATCH ReconciliationResultType = "HIGH_CONFIDENCE_MATCH"
	ReconciliationResultTypeLOWCONFIDENCEMATCH  ReconciliationResultType = "LOW_CONFIDENCE_MATCH"
	ReconciliationResultTypeMISSINGINAPP        ReconciliationResultType = "MISSING_IN_APP"
	ReconciliationResultTypeNOTINSTATEMENT      ReconciliationResultType = "NOT_IN_STATEMENT"
	ReconciliationResultTypeMANUALLYMATCHED     ReconciliationResultType = "MANUALLY_MATCHED"
	ReconciliationResultTypeCASHTRANSACTION     ReconciliationResultType = "CASH_TRANSACTION"
)

func (e *ReconciliationResultType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ReconciliationResultType(s)
	case string:
		*e = ReconciliationResultType(s)
	default:
		return fmt.Errorf("unsupported scan type for ReconciliationResultType: %T", src)
	}
	return nil
}

type NullReconciliationResultType struct {
	ReconciliationResultType ReconciliationResultType
	Valid                    bool // Valid is true if ReconciliationResultType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullReconciliationResultType) Scan(value interface{}) error {
	if value == nil {
		ns.ReconciliationResultType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ReconciliationResultType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullReconciliationResultType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ReconciliationResultType), nil
}

type TransactionReconciliationStatus string

const (
	TransactionReconciliationStatusUNRECONCILED  TransactionReconciliationStatus = "UNRECONCILED"
	TransactionReconciliationStatusAUTOVERIFIED  TransactionReconciliationStatus = "AUTO_VERIFIED"
	TransactionReconciliationStatusPENDINGREVIEW TransactionReconciliationStatus = "PENDING_REVIEW"
	TransactionReconciliationStatusUSERVERIFIED  TransactionReconciliationStatus = "USER_VERIFIED"
	TransactionReconciliationStatusREJECTED      TransactionReconciliationStatus = "REJECTED"
)

func (e *TransactionReconciliationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransactionReconciliationStatus(s)
	case string:
		*e = TransactionReconciliationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TransactionReconciliationStatus: %T", src)
	}
	return nil
}

type NullTransactionReconciliationStatus struct {
	TransactionReconciliationStatus TransactionReconciliationStatus
	Valid                           bool // Valid is true if TransactionReconciliationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransactionReconciliationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TransactionReconciliationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransactionReconciliationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransactionReconciliationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransactionReconciliationStatus), nil
}

type TransactionSource string

const (
	TransactionSourceSMS           TransactionSource = "SMS"
	TransactionSourceMANUAL        TransactionSource = "MANUAL"
	TransactionSourceSTATEMENTAUTO TransactionSource = "STATEMENT_AUTO"
)

func (e *TransactionSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransactionSource(s)
	case string:
		*e = TransactionSource(s)
	default:
		return fmt.Errorf("unsupported scan type for TransactionSource: %T", src)
	}
	return nil
}

type NullTransactionSource struct {
	TransactionSource TransactionSource
	Valid             bool // Valid is true if TransactionSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransactionSource) Scan(value interface{}) error {
	if value == nil {
		ns.TransactionSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransactionSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransactionSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransactionSource), nil
}

type TxnType string

const (
	TxnTypeDEBIT        TxnType = "DEBIT"
	TxnTypeCREDIT       TxnType = "CREDIT"
	TxnTypeSUBSCRIPTION TxnType = "SUBSCRIPTION"
	TxnTypeINVESTMENT   TxnType = "INVESTMENT"
	TxnTypeINCOME       TxnType = "INCOME"
	TxnTypeREFUND       TxnType = "REFUND"
)

func (e *TxnType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TxnType(s)
	case string:
		*e = TxnType(s)
	default:
		return fmt.Errorf("unsupported scan type for TxnType: %T", src)
	}
	return nil
}

type NullTxnType struct {
	TxnType TxnType
	Valid   bool // Valid is true if TxnType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTxnType) Scan(value interface{}) error {
	if value == nil {
		ns.TxnType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TxnType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTxnType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TxnType), nil
}

type UploadProcessingStatus string

const (
	UploadProcessingStatusUPLOADED   UploadProcessingStatus = "UPLOADED"
	UploadProcessingStatusPROCESSING UploadProcessingStatus = "PROCESSING"
	UploadProcessingStatusCOMPLETED  UploadProcessingStatus = "COMPLETED"
	UploadProcessingStatusFAILED     UploadProcessingStatus = "FAILED"
	UploadProcessingStatusCANCELLED  UploadProcessingStatus = "CANCELLED"
)

func (e *UploadProcessingStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UploadProcessingStatus(s)
	case string:
		*e = UploadProcessingStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UploadProcessingStatus: %T", src)
	}
	return nil
}

type NullUploadProcessingStatus struct {
	UploadProcessingStatus UploadProcessingStatus
	Valid                  bool // Valid is true if UploadProcessingStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUploadProcessingStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UploadProcessingStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UploadProcessingStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUploadProcessingStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UploadProcessingStatus), nil
}

type Account struct {
	ID             pgtype.UUID
	UserID         string
	BankID         pgtype.UUID
	AccountNumber  string
	AccountType    string
	AccountName    pgtype.Text
	CurrentBalance pgtype.Numeric
	IsPrimary      pgtype.Bool
	IsActive       pgtype.Bool
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	DeletedAt      pgtype.Timestamp
}

type ActivityLog struct {
	ID         pgtype.UUID
	UserID     pgtype.Text
	Action     string
	EntityType pgtype.Text
	EntityID   pgtype.UUID
	IpAddress  pgtype.Text
	UserAgent  pgtype.Text
	Metadata   []byte
	CreatedAt  pgtype.Timestamp
	UpdatedAt  pgtype.Timestamp
}

type Bank struct {
	ID        pgtype.UUID
	Name      string
	Code      pgtype.Text
	IsActive  pgtype.Bool
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

type BankStatementUpload struct {
	ID                     pgtype.UUID
	UserID                 string
	AccountID              pgtype.UUID
	FileName               string
	FileType               pgtype.Text
	FileSize               pgtype.Int4
	StatementPeriodStart   pgtype.Date
	StatementPeriodEnd     pgtype.Date
	UploadStatus           pgtype.Text
	ProcessingStartedAt    pgtype.Timestamp
	ProcessingCompletedAt  pgtype.Timestamp
	TotalTransactionsFound pgtype.Int4
	MatchedTransactions    pgtype.Int4
	UnmatchedTransactions  pgtype.Int4
	MissingTransactions    pgtype.Int4
	ErrorMessage           pgtype.Text
	CreatedAt              pgtype.Timestamp
	UpdatedAt              pgtype.Timestamp
	// Current processing state of the upload
	ProcessingStatus NullUploadProcessingStatus
	DuplicateRows    pgtype.Int4
	ErrorRows        pgtype.Int4
	ValidRows        pgtype.Int4
	// Array of parsing errors: [{"row": 23, "error": "Invalid date", "data": {...}}]
	ParsingErrors []byte
	JobID         pgtype.UUID
}

type Category struct {
	ID               pgtype.UUID
	Name             string
	UserID           pgtype.Text
	ParentCategoryID pgtype.UUID
	Icon             pgtype.Text
	Color            pgtype.Text
	Type             string
	IsSystem         pgtype.Bool
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
}

type Goal struct {
	ID            pgtype.UUID
	UserID        string
	Name          string
	TargetAmount  pgtype.Numeric
	CurrentAmount pgtype.Numeric
	TargetDate    pgtype.Date
	Status        pgtype.Text
	Priority      pgtype.Int4
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	AchievedAt    pgtype.Timestamp
}

type GoalInvestment struct {
	ID                pgtype.UUID
	GoalID            pgtype.UUID
	InvestmentType    string
	ContributionType  string
	ContributionValue pgtype.Numeric
	CurrentValue      pgtype.Numeric
	AccountID         pgtype.UUID
	AutoInvest        pgtype.Bool
	InvestmentDay     pgtype.Int4
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
}

type GoalTransaction struct {
	ID              pgtype.UUID
	GoalID          pgtype.UUID
	InvestmentID    pgtype.UUID
	TransactionID   pgtype.UUID
	Amount          pgtype.Numeric
	TransactionDate pgtype.Timestamp
	Notes           pgtype.Text
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

type Job struct {
	ID             pgtype.UUID
	UserID         pgtype.Text
	JobType        NullJobType
	JobID          pgtype.Text
	Status         NullJobStatus
	Payload        []byte
	Result         []byte
	Attempts       pgtype.Int4
	MaxAttempts    pgtype.Int4
	LastError      pgtype.Text
	Priority       pgtype.Int4
	QueueName      pgtype.Text
	StartedAt      pgtype.Timestamp
	LockedAt       pgtype.Timestamp
	FinishedAt     pgtype.Timestamp
	LockedBy       pgtype.Text
	TimeoutSeconds pgtype.Int4
	Metadata       []byte
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
}

type Merchant struct {
	ID                pgtype.UUID
	Name              string
	NormalizedName    pgtype.Text
	DefaultCategoryID pgtype.UUID
	MccCode           pgtype.Text
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
}

type MonthlyBudget struct {
	ID           pgtype.UUID
	UserID       string
	CategoryID   pgtype.UUID
	AllocationID pgtype.UUID
	MonthYear    pgtype.Date
	BudgetAmount pgtype.Numeric
	SpentAmount  pgtype.Numeric
	CreatedAt    pgtype.Timestamp
	UpdatedAt    pgtype.Timestamp
}

type MonthlyExpenseAllocation struct {
	ID                   pgtype.UUID
	UserID               string
	Name                 string
	CategoryID           pgtype.UUID
	AllocatedAmount      pgtype.Numeric
	AllocationPercentage pgtype.Numeric
	Priority             pgtype.Int4
	IsActive             pgtype.Bool
	DeletedAt            pgtype.Timestamp
	CreatedAt            pgtype.Timestamp
	UpdatedAt            pgtype.Timestamp
}

type NotificationPreference struct {
	ID               pgtype.UUID
	UserID           string
	NotificationType string
	EmailEnabled     pgtype.Bool
	ThresholdAmount  pgtype.Numeric
	DaysBefore       pgtype.Int4
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
}

type RecurringTransaction struct {
	ID                    pgtype.UUID
	UserID                string
	AccountID             pgtype.UUID
	CategoryID            pgtype.UUID
	MerchantID            pgtype.UUID
	AllocationID          pgtype.UUID
	Name                  string
	Amount                pgtype.Numeric
	IsFixedAmount         pgtype.Bool
	Frequency             string
	StartDate             pgtype.Date
	NextDueDate           pgtype.Date
	EndDate               pgtype.Date
	AutoCreateTransaction pgtype.Bool
	ReminderEnabled       pgtype.Bool
	ReminderDaysBefore    pgtype.Int4
	IsActive              pgtype.Bool
	DeletedAt             pgtype.Timestamp
	CreatedAt             pgtype.Timestamp
	UpdatedAt             pgtype.Timestamp
}

type SmsLog struct {
	ID                pgtype.UUID
	UserID            string
	Sender            string
	RawMessage        string
	ReceivedAt        pgtype.Timestamp
	ParsingStatus     pgtype.Text
	ErrorMessage      pgtype.Text
	RetryCount        pgtype.Int4
	LlmParsed         pgtype.Bool
	LlmParseAttempted pgtype.Bool
	LlmResponse       pgtype.Text
	CreatedAt         pgtype.Timestamp
	LastRetryAt       pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
}

type SpendingLimit struct {
	ID             pgtype.UUID
	UserID         string
	CategoryID     pgtype.UUID
	LimitType      string
	LimitAmount    pgtype.Numeric
	StartDate      pgtype.Date
	EndDate        pgtype.Date
	AlertThreshold pgtype.Numeric
	CurrentSpent   pgtype.Numeric
	LastResetAt    pgtype.Timestamp
	IsActive       pgtype.Bool
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
}

type StatementTransaction struct {
	ID              pgtype.UUID
	UploadID        pgtype.UUID
	AccountID       pgtype.UUID
	TransactionDate pgtype.Timestamptz
	Description     pgtype.Text
	Amount          pgtype.Numeric
	Type            string
	Balance         pgtype.Numeric
	ReferenceNumber pgtype.Text
	RawData         []byte
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	// SHA256 hash of (date + amount + description + reference_number + row_position) for duplicate detection
	RawRowHash string
	// Original position in Excel file (1-based)
	RowNumber   int32
	IsDuplicate pgtype.Bool
}

type Transaction struct {
	ID                   pgtype.UUID
	UserID               string
	AccountID            pgtype.UUID
	ToAccountID          pgtype.UUID
	CategoryID           pgtype.UUID
	MerchantID           pgtype.UUID
	Type                 TxnType
	Amount               pgtype.Numeric
	Description          pgtype.Text
	Notes                pgtype.Text
	Tags                 pgtype.Text
	TransactionDate      pgtype.Timestamp
	SmsID                pgtype.UUID
	PaymentMethod        pgtype.Text
	ReferenceNumber      pgtype.Text
	IsRecurring          pgtype.Bool
	IsExcluded           pgtype.Bool
	IsCash               pgtype.Bool
	DeletedAt            pgtype.Timestamp
	DeletedBy            pgtype.Text
	CreatedAt            pgtype.Timestamp
	UpdatedAt            pgtype.Timestamp
	Source               NullTransactionSource
	ReconciliationStatus NullTransactionReconciliationStatus
	ReconciledBy         NullReconciliationActor
	ReconciledAt         pgtype.Timestamp
	StatementTxnID       pgtype.UUID
}

type TransactionAttachment struct {
	ID                pgtype.UUID
	TransactionID     pgtype.UUID
	FileName          string
	FileUrl           string
	FileType          pgtype.Text
	FileSize          pgtype.Int4
	ThumbnailUrl      pgtype.Text
	LlmParsed         pgtype.Bool
	LlmParseAttempted pgtype.Bool
	LlmExtractedData  []byte
	UploadedBy        string
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
}

type TransactionReconciliation struct {
	ID                     pgtype.UUID
	UploadID               pgtype.UUID
	StatementTransactionID pgtype.UUID
	AppTransactionID       pgtype.UUID
	MatchStatus            string
	ConfidenceScore        pgtype.Numeric
	AmountDifference       pgtype.Numeric
	DateDifference         pgtype.Int4
	UserAction             pgtype.Text
	UserActionAt           pgtype.Timestamp
	Notes                  pgtype.Text
	CreatedAt              pgtype.Timestamp
	UpdatedAt              pgtype.Timestamp
	// Type of reconciliation result
	ResultType ReconciliationResultType
	// JSON object explaining why match occurred: {"date_match": true, "amount_match": true, "description_similarity": 0.85}
	MatchSignals []byte
	// Reference to transaction auto-created from this statement txn
	AutoCreatedTxnID pgtype.UUID
	ReviewedBy       NullReconciliationActor
	ReviewedAt       pgtype.Timestamp
}

type User struct {
	ClerkID                        string
	Email                          string
	DatabaseUrl                    pgtype.Text
	LifetimeIncome                 pgtype.Numeric
	LifetimeExpense                pgtype.Numeric
	UseLlmParsing                  pgtype.Bool
	LlmParseCredits                pgtype.Int4
	IsActive                       pgtype.Bool
	CreatedAt                      pgtype.Timestamp
	UpdatedAt                      pgtype.Timestamp
	TransactionImageParseAttempts  pgtype.Int4
	TransactionImageParseSuccesses pgtype.Int4
	ApiKey                         pgtype.Text
	QrString                       pgtype.Text
	// Confidence threshold (0-100) for auto-verification. Default: 70
	ReconciliationThreshold pgtype.Int4
}

type UserNotification struct {
	ID               pgtype.UUID
	UserID           string
	NotificationType string
	Title            string
	Message          string
	EntityType       pgtype.Text
	EntityID         pgtype.UUID
	Priority         pgtype.Text
	EmailSent        pgtype.Bool
	EmailSentAt      pgtype.Timestamp
	EmailError       pgtype.Text
	IsRead           pgtype.Bool
	ReadAt           pgtype.Timestamp
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: goal.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGoal = `-- name: CreateGoal :one
INSERT INTO goals (
user_id,name,target_amount,current_amount,target_date,status,priority
)VALUES (
$1,$2,$3,$4,$5,$6,$7
)RETURNING id, user_id, name, target_amount, current_amount, target_date, status, priority, created_at, updated_at, achieved_at
`

type CreateGoalParams struct {
	UserID        string
	Name          string
	TargetAmount  pgtype.Numeric
	CurrentAmount pgtype.Numeric
	TargetDate    pgtype.Date
	Status        pgtype.Text
	Priority      pgtype.Int4
}

func (q *Queries) CreateGoal(ctx context.Context, arg CreateGoalParams) (Goal, error) {
	row := q.db.QueryRow(ctx, createGoal,
		arg.UserID,
		arg.Name,
		arg.TargetAmount,
		arg.CurrentAmount,
		arg.TargetDate,
		arg.Status,
		arg.Priority,
	)
	var i Goal
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.TargetAmount,
		&i.CurrentAmount,
		&i.TargetDate,
		&i.Status,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AchievedAt,
	)
	return i, err
}

const getGoalById = `-- name: GetGoalById :one
SELECT id, user_id, name, target_amount, current_amount, target_date, status, priority, created_at, updated_at, achieved_at FROM goals g
WHERE g.id=$1 AND g.user_id=$2
`

type GetGoalByIdParams struct {
	ID     pgtype.UUID
	UserID string
}

func (q *Queries) GetGoalById(ctx context.Context, arg GetGoalByIdParams) (Goal, error) {
	row := q.db.QueryRow(ctx, getGoalById, arg.ID, arg.UserID)
	var i Goal
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.TargetAmount,
		&i.CurrentAmount,
		&i.TargetDate,
		&i.Status,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AchievedAt,
	)
	return i, err
}

const getGoals = `-- name: GetGoals :many
SELECT g.id, g.user_id, g.name, g.target_amount, g.current_amount, g.target_date, 
       g.status, g.priority, g.created_at, g.updated_at, g.achieved_at
FROM goals g
WHERE g.user_id = $1
AND ($2::text IS NULL OR g.status = $2::text)
AND ($3::integer IS NULL OR g.priority = $3::integer)
AND ($4::numeric IS NULL OR g.target_amount <= $4::numeric)
AND ($5::numeric IS NULL OR g.target_amount >= $5::numeric)
AND ($6::timestamp IS NULL OR g.created_at >= $6::timestamp)
AND ($7::date IS NULL OR g.target_date <= $7::date)
AND ($8::date IS NULL OR g.target_date >= $8::date)
`

type GetGoalsParams struct {
	UserID       string
	Status       pgtype.Text
	Priority     pgtype.Int4
	MaxAmount    pgtype.Numeric
	MinAmount    pgtype.Numeric
	CreatedAfter pgtype.Timestamp
	TargetBefore pgtype.Date
	TargetAfter  pgtype.Date
}

func (q *Queries) GetGoals(ctx context.Context, arg GetGoalsParams) ([]Goal, error) {
	rows, err := q.db.Query(ctx, getGoals,
		arg.UserID,
		arg.Status,
		arg.Priority,
		arg.MaxAmount,
		arg.MinAmount,
		arg.CreatedAfter,
		arg.TargetBefore,
		arg.TargetAfter,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Goal
	for rows.Next() {
		var i Goal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.TargetAmount,
			&i.CurrentAmount,
			&i.TargetDate,
			&i.Status,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AchievedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGoal = `-- name: UpdateGoal :one
UPDATE goals
SET
  name            = COALESCE(NULLIF($1::varchar, ''), name),
  target_amount   = COALESCE($2::numeric, target_amount),
  target_date     = COALESCE($3::date, target_date),
  status          = COALESCE(NULLIF($4::varchar, ''), status),
  priority        = COALESCE(NULLIF($5::int, 0), priority),
  current_amount  = COALESCE($6::numeric, current_amount),
  achieved_at     = COALESCE($7::timestamp, achieved_at)
WHERE id = $8
  AND user_id = $9
RETURNING id, user_id, name, target_amount, current_amount, target_date, status, priority, created_at, updated_at, achieved_at
`

type UpdateGoalParams struct {
	Column1 string
	Column2 pgtype.Numeric
	Column3 pgtype.Date
	Column4 string
	Column5 int32
	Column6 pgtype.Numeric
	Column7 pgtype.Timestamp
	ID      pgtype.UUID
	UserID  string
}

func (q *Queries) UpdateGoal(ctx context.Context, arg UpdateGoalParams) (Goal, error) {
	row := q.db.QueryRow(ctx, updateGoal,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.ID,
		arg.UserID,
	)
	var i Goal
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.TargetAmount,
		&i.CurrentAmount,
		&i.TargetDate,
		&i.Status,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AchievedAt,
	)
	return i, err
}
